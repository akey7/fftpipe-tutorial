---
title: "fftpipe Tutorial"
description: |
  How to use the fftpipe package for R.
author:
  - name: Alicia M. F. Key 
    url: https://scialicia.com
    affiliation: Personal Projects
    affiliation_url: https://scialicia.com
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## What is fftpipe?

`fftpipe` is a package of functions that wrap around the base R [`fft()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/fft) function. The `fftpipe` package enables workflows around the [`fft()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/fft) function that use the pipe (`%>%`) operator. I took inspiration for the interface to `fftpipe` from the [Tidyverse](https://www.tidyverse.org) and [tidymodels](https://www.tidymodels.org) packages.

Specifically, `fftpipe` offers the following functionality:

1. Waveform generation,
2. FFT and inverse FFT transformation,
3. Plotting of these waveforms and FFTs.

## Installation

Install `fftpipe` from GitHub with devtools. If you don't have devtools installed already, install it with `install.packages("devtools")`. Once devtools is installed, you can then install `fftpipe` by typing the following command into the R console:

```
devtools::install_github("akey7/fftpipe")
```

## Quick Start

More detail about each of these steps is described below in this document. But this will get you started!

### Load the necessary packages

While you can use `fftpipe` on its own, it is designed to work within the [Tidyverse](https://www.tidyverse.org) ecosystem, so I recommend you load the tidyverse as well. Also, I will set a theme for `ggplot()`.

```{r}
suppressPackageStartupMessages(library(fftpipe))
suppressPackageStartupMessages(library(tidyverse))
theme_set(theme_linedraw(base_size = 15))
```

### Generate a waveform

Waveforms can either be built from external data or synthesized from within the `fftpipe` package. For this quick start demo, let's compose a waveform to feed into the FFT with the following properties:

1. Its duration will be 1 second with a sample rate of 200 samples/second.
2. It will be the sum of 2 cosines, with the second cosine being 3x the frequency and 50% the amplitude of the first cosine.
3. Its total amplitude will decrease with an exponential decay function, with an [exponential time constant (tau)](https://en.wikipedia.org/wiki/Exponential_decay#Mean_lifetime) of 0.5.
4. The final result will be normalized by dividing the vector of values by the length of that vector to prepare the waveform for FFT.

We can compose this waveform using functions from fftpipe as shown in this code block:

```{r}
wv <- waveform(duration_s = 1.0, sr = 100) %>%
  cos_sum(freqs = c(2.0, 6.0), amplitudes = c(1.0, 0.9)) %>%
  length_norm()
```

### Plot the input waveform

We can streamline plotting the input waveform with the following function call. This plot can be refined in ways I'll describe later in the document.

```{r}
waveform_plot(wv)
```

### Perform the FFT

We can perform an FFT on the waveform we just made. To do that, run the following line:

```{r}
wv_fft <- wv %>%
  compute_fft()
```

We can then use this FFT `data.frame` to plot the FFT and reconstruct the original waveform in the next two steps.

### Plot the FFT

`fft_plot()` plots the FFT as shown below. By default, the plot only shows the frequency components that are at or below the [Nyquist frequency (half the sample rate)](https://en.wikipedia.org/wiki/Nyquist_frequency). Here, our sample rate is 100 Hz, so the maximum frequency is 50 Hz. This plot can be further customized, which will be shown later in the document.

Note how our original component cosines we summed together appear here as peaks at 2 Hz and 6 Hz. The first peak is taller than the second peak, which corresponds to our 6 Hz component having less amplitude than the 2 Hz component. Hence, our FFT captured the frequencies of our original waveform!

```{r}
wv_fft %>%
  fft_plot()
```

### Reconstruct the original waveform from the FFT

Finally, we can reconstruct the original waveform from the FFT. First, we need to make a waveform that defines the sample rate and values for the waveform to be reconstructed. This should match the `waveform()` call above. Then we need to feed both the new waveform and FFT into the `inverse_FFT()`. Then, we can pass the reconstruction through a `length_norm()` call and plot the reconstructed waveform.

```{r}
waveform(duration_s = 1.0, sr = 100) %>%
  inverse_fft(wv_fft) %>%
  length_norm() %>%
  waveform_plot()
```

By using `length_norm()` before and after the FFT, the amplitudes of our waveform are the same before and after the FFT.

## In Depth

In this section, I will go over the capabilities of the `fftpipe` package in more detail. This section will cover:

1. Plot customization with labels and themeing
2. Signal denoising

### Plot Customization

TODO

### Signal Denoising

Signal denoising is a simple way to remove noise from a signal through the following steps:

1. FFT the noisy signal
2. Inspect the power spectral density (PSD) for each Fourier coefficient
3. Observe that the coeffficients encoding the signal have a higher PSD than the noise coefficients.
4. Zero the coefficients that do not meet a PSD threshold.
5. Run and inverse FFT to reconstruct a waveform with reduced noise.

All of these steps can be accomplished with functions in `fftpipe`.

#### Create Clean and Noisy Signals

Let's make the sample rate higher than we have been using so far so that it can capture the high frequency white noise better. First, let's make a clean signal and inspect its waveform and PSD plot.

```{r}
# sr = 500 Hz, maximum frequency that can be sampled is 250 Hz.
wv <- waveform(duration_s = 1.0, sr = 500) 

# length_norm() makes the FFT in a later step easier.
wv_clean <- wv %>%
  cos_sum(
    freqs = c(5, 10, 20), 
    amplitudes = c(1.0, 0.875, 0.75), 
    phases = c(2*pi/3, 0, 2*pi/4))

wv_clean_fft <- wv_clean %>%
  length_norm() %>%
  compute_fft()
```

Create the plots of the clean signal:

```{r}
wv_clean %>%
  waveform_plot(
    title = "Clean Signal",
    x = "t (s)", 
    y = "f(t)"
  )
```

```{r}
wv_clean_fft %>%
  fft_plot(title = "PSD of Fourier Coefficients, Clean Signal", x = "Hz", y = "PSD")
```

Now let's add some noise! 

The `white_noise()` function adds noise from a Gaussian distribution to the signal.

```{r}
set.seed(123)

wv_noisy <- wv_clean %>%
  white_noise(mean = 0, sd = 1e-3)

wv_noisy_fft <- wv_noisy %>%
  length_norm() %>%
  compute_fft()
```

As before, let's plot the waveform and the PSD of the first half of Fourier coefficients.

```{r}
wv_noisy %>%
  waveform_plot(
    title = "Noisy Signal",
    x = "t (s)", 
    y = "f(t)"
  )
```

```{r}
wv_noisy_fft %>%
  fft_plot(title = "PSD of Fourier Coefficients, Noisy Signal", x = "Hz", y = "PSD")
```

Note that a bunch of Fourier coefficients have lit up with very small PSD values. When we drop these coefficients to zero, we will recover clean FOurier coefficients. Then, when we do an inverse Fourier transform on the cleaned coefficients, we will recover the signal from the noise.

```{r}
wv_noisy_but_cleaned <- wv_noisy_fft %>%
  denoise_fft(psd_thresh = 5e-2) %>%
  inverse_fft(wv, .) %>%
  length_norm()

wv_noisy_but_cleaned %>%
  waveform_plot(
    title = "Waveform With Noise Removed", 
    x = "t (s)", 
    y = "f(t)"
  )
```


